# Common Vulnerability Quick Reference

## Table of content

- ### [Reward System](#reward-system)

- ### [Functional bypass](#functional-bypass)

- ### [Denial of Service](#denial-of-service)

- ### [Input Validation](#input-validation)

  - #### Incorrect input validation

  - [Migration data decoding failure](#migration)

  - #### Strict Validation

  - [Withdrawal transactions can get stuck if output root is reproposed](#withdrawal)

## <a id="reward-system"></a>Reward system

### Retroactive reward distribution

- [Aquarius- H. Boost modifications apply retroactively to reward shares, allowing boosting of past timespans](../2025/May/Aquarius/Other-report.md#h01-boost-modifications-apply-retroactively-to-reward-shares-allowing-boosting-of-past-timespans)

### Token distribution mismatch

- [Aquarius- M. Reward Emissions Accumulate Even When Pool Has No Liquidity, Causing Irrecoverable Token Lock](../2025//May/Aquarius/Other-report.md#m02-reward-emissions-accumulate-even-when-pool-has-no-liquidity-causing-irrecoverable-token-lock)

## <a id="functional-bypass"></a> Functional bypass

- [Aquarius- M. Stableswap pools can have price changes even when swaps are killed](../2025//May/Aquarius/Other-report.md#m01-stableswap-pools-can-have-price-changes-even-when-swaps-are-killed)

## <a id="denial-of-service"></a>DoS (Denial of Service)

- [Aquarius- M. Stableswap calculator fails due to 0 value swaps](../2025/May/Aquarius/Other-report.md#m03-stableswap-calculator-fails-due-to-0-value-swaps)

## <a id="input-validation"></a>Input Validation

### <a id="migration"></a>Migration data decoding failure - Optimism

- [Migration can be bricked by sending a message directly to the LegacyMessagePasser](https://github.com/sherlock-audit/2023-01-optimism-judging/issues/105)

### <a id="withdrawal"></a>Withdrawal transactions can get stuck if output root is reproposed - Optimism

<details>
<summary><a href="https://github.com/sherlock-audit/2023-01-optimism-judging/issues/53">Withdrawal transactions can get stuck if output root is reproposed</a></summary>

## The Issue

• Users prove withdrawal against output index X  
• Output at index X gets challenged and replaced with different content  
• Validation only allows reproving at same index X (too strict)  
• User's withdrawal no longer exists at index X  
• User cannot reprove at different index → funds permanently locked  

## How to Spot Similar Bugs

• **Overly strict validation** that assumes external state never changes  
• **Hard-coded index/ID references** in dispute-able systems  
• **Missing flexibility** when external dependencies get updated  

</details>
